---
title: "[OS]운영체제_10"
excerpt: "메인 메모리 관리"
toc: true
toc_sticky: true

categories:
  - etc
  - OS
tags:
  - etc
  - OS
last_modified_at: 2020-03-30T01:15:00
---


# 메인 메모리 관리

## OS에서 제일 중요한 기능

+ 프로세스 관리 : CPU자원을 나눠줌
+ 메인메모리 관리 


+ 메모리 역사
    - Core memory : 반지모양의 철심에 자석모양을 나둬서 전기를 흘러보내는 방식
    - 진공관 메모리
    - 트랜지스터 메모리
    - 집적회로 메모리: SRAM, DRAM

+ 메모리 용량
    - 1970년대: 8-bit PC 64KB
    - 1980년: 16-bit IBM-PC 640KB > 1MB > 4MB
    - 1990년: 수MB > 수십 MB
    - 2000년~: 수백 MB > 수 GB

## 언제나 부족한 메모리

+ 프로그램 변천
    - 기계어/어셈블리어 작성
    - C언어 작성
    - 자바, 객체지향형 언어 작성
    - 숫자 처리 > 문자 처리 > 멀티미디어 처리 > Big Data
+ 메모리 용량 증가 vs 프로그램 크기 증가
    - 언제나 부족한 메모리
+ 어떻게 메모리를 효과적으로 사용할까?
    - 메모리 낭비 없애기
    - 가상 메모리 사용하기(virtual memory)

## 프로그램을 메모리에 올리기

+ 메모리구조
    - 주소(Address) + 데이터(Data)
+ 프로그램 개발
    1. 원천파일(Source file) : 고수준언어 또는 어셈블리언어
    2. 목적파일(Object file) : 컴파일 또는 어셈블 결과
    3. 실행파일 (Executable file): 링크 결과
    - 컴파일러 : 고수준언어를 오브젝트코드로 변환해주는 프로그램
    - 링커 : 목적파일과 라이브러리를 연결해주는 프로그램
    - 로드 : 실행파일을 메인메모리로 적재해주는 프로그램
    - 어셈블러 : 어셈블리언어를 기계어로 만들어주는 프로그램
+ 프로그램 실행
    - code + data + stack

+ 실행파일을 메모리에 올리기
    - MMU(memory management unit)재배치 레지스터 사용 하여 재배치(CPU가 봤을때는 0번지이지만 OS가 relocation 레지스터값을 바꿔줌으로서 실제주소값으로 변경한다)
    - cpu가 보내는 주소(논리주소) !== MMU를 통과해서 메인메모리를 들어간(물리주소)
    - MMU : base + limit + relocation레지스터


## 메모리 낭비 방지

+ 동적 적재(Dynamic Loading) : 프로그램 실행에 반드시 필요한 루틴/데이터만 적재
    - 모든 루틴(함수 , 프로세스 등..)이 다 사용되는 것은 아니다(예 : 오류처리)
    - 모든 데이터가 다 사용되는 것은 아니다(예 : 배열)
    - 자바 : 모든 클래스가 다 사용되는 것은 아니다.
    - 실행 시 필요하면 그때 해당 부분을 메모리에 올린다.

+ 동적 연결(Dynamic Linking) : 여러 프로그램에 공통적으로 사용되는 라이브러리
    - 공통 라이브러리 루틴(library routine)을 메모리에 중복으로 올리는것은 낭비
    - 라이브러리 루틴 연결을 실행 시까지 미룬다. 
    - 오직 하나의 라이브러리 루틴만 메모리에 적재
    - 다른 애플리케이션 실행시 이 루틴과 연결
    - **공유 라이브러리(shared library)** - Linux
    - **동적 연결 라이브러리 (Dynamic Linking Library)** - Windows

+ Swapping : 메모리에 적재되어 있으나 현재 사용되지 않는 프로세스를 몰아냄
    - 메모리 활용도 높이기 위해 Backing Store (=Swap device)로 몰아내기
    - swap-out vs swap-in
    - Relocation register 사용으로 적재위치는 무관
    - 프로세스 크기가 크면 backing store 입출력에 따른 부담 크다

## 연속 메모리 할당    

+ 다중프로그래밍 환경
    - 부팅 직후 메모리 상태: O/S + big single hole(비어져있는 상태)
    - 프로세스 생성 & 종료 반복 ☞ scattered holes
+ 메모리 단편화 (Memory fragmentation)
    - Hole 들이 불연속하게 흩어져 있기 때문에 프로세스 적재 불가
    - 외부 단편화 발생(external fragmentation) : hole들이 떨어져 있기때문에 프로그램이 못들어가는 상태발생

### 외부 단편화 최소화 방법
+ 연속 메모리 할당 방식
    - First-fit (최초 적합) : 메모리를 순차적으로 찾아 처음의 위치
    - Best-fit (최적 적합) : 크기가 제일 비슷한곳
    - Worst-fit (최악 적합) : 크기가 제일 안맞는곳에 넣음
    - 할당 방식 성능 비교 : 속도
     * 속도 : first-fit 
     * 이용률 : first-fit , best-fit 
    - 외부 단편화로 인한 메모리 낭비: 1/3 수준 (사용 불가)
     * Compaction : 최적 알고리즘 없음, 고부담 (흩어져있는 hole들을 한곳으로 모음)

+ 페이징 (Paging)
    - 프로세스를 일정 크기(=페이지)로 잘라서 메모리에!
        * 프로세스를 자른것을 페이지(page) > 프로세스는 페이지의 집합
        * 메모리를 자른것을 프레임(frame) > 메모리는 프레임의 집합
    - 페이지를 프레임에 할당
        * MMU 내의 재배치 레지스터 값을 바꿈으로서
        * CPU 는 프로세스가 연속된 메모리 공간에 위치한다고 착각
        * MMU 는 페이지 테이블 (page table) 이 된다.

### 주소 변환 (Address Translation)
    
+ 논리주소 (Logical address)
    - CPU 가 내는 주소는 2진수로 표현 (전체 m 비트)
    - 하위 n 비트는 오프셋(offset) 또는 변위(displacement)
    - 상위 m-n 비트는 페이지 번호
+ 주소변환: 논리주소 → 물리주소 (Physical address)
    - 페이지 번호(p)는 페이지 테이블 인덱스 값
    - p 에 해당되는 테이블 내용이 프레임 번호(f) – 변위(d)는 변하지 않음

