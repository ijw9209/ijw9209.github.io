---
title: "[OS]운영체제_7"
excerpt: "전통적 동기화 예제"
toc: true
toc_sticky: true

categories:
  - etc
  - OS
tags:
  - etc
  - OS
last_modified_at: 2020-03-18T01:15:00
---


## 운영체제 프로세스 관리 중에서 가장 중요한 두가지

+ 프로세스 스케쥴링
 - 레디큐에서 대기중인 여러 프로세스중에 누가 cpu서비스를 받게할것인가
+ 프로세스 동기화
 - 

## 전통적 동기화 예제

+ 생산자-소비자 문제
 - **생산자가 데이터를 생산하면 소비자는 그것을 소비**
 - 예) 컴파일러 > 어셈블러 , 파일서버 > 클라이언트, 웹서버 > 웹클라이언트
 - 생산자가 데이터를 생산하는 속도와 소비자가 소비하는 속도가 달라서 생산자는 창고 (buffer)에 저장을 함 저장된것들을 소비자가 사용
 - 현실 시스템에서 버퍼크기는 유한(Bounded-Buffer)
 - 생산자는 버퍼가 가득차면 더 넣을 수 없다.
 - 소비자는 버퍼가 비면 뺄수 없다.

 - 잘못된결과 
    * 실행불가 , count != 0 (생산된 항목 숫자 != 소비된 항목 숫자)
 - 이유
    * 공통변수 업데이트 구간(= 임계구역)에 대한 동시 진입
 - 해결법
    * 세마포를 사용한 상호베타(mutual exclusion) 적용

 - Busy-wait(버퍼가 비었는지, 가져올수있는 확인, 기다리면서 메모리의 자원을 소비)
    * 생산자: 버퍼가 가득 차면 기다려야 = 빈(empty) 공간이 있어야
    * 소비자: 버퍼가 비면 기다려야 = 찬(full) 공간이 있어야  
 - 세마포를 사용하여 busy-wait 회피
    * 생산자: empty.acquire() // # of permit = BUF_SIZE
    * 소비자: full.acquire() // # of permit = 0
